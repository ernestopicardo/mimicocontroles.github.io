<html>
<!--
README
******
- Edge-to-edge connections: We store the point where the mouse
was released in the terminal points of the edge geometry and
use that point to find the nearest segment on the target edge
and the connection point between the two edges in
mxGraphView.updateFixedTerminalPoint.

- The orthogonal router, which is implemented as an edge style,
computes its result based on the output of mxGraphView.
updateFixedTerminalPoint, which computes all connection points
for edge-to-edge connections and constrained ports and vertices
and stores them in state.absolutePoints. 

- Routing directions are stored in the 'portConstraint' style.
Possible values for this style horizontal and vertical. Note
that this may have other values depending on the edge style.

- For edge-to-edge connections, a 'source-/targetConstraint'
style is added in updateFixedTerminalPoint that contains the
orientation of the segment that the edge connects to. Possible
values are horizontal, vertical.

- An alternative solution for connection points via connection
constraints is demonstrated. In this setup, the edge is connected
to the parent cell directly. There are no child cells that act
as "ports". Instead, the connection information is stored as a
relative point in the connecting edge. (See also: portrefs.html
for storing references to ports.)

-->
<head>
	<title>Circuito Controles</title>

</head>
<body onload="main()">
	<div id="toolbar"class="herramientas"></div>
	<div id="graphContainer" class="flujo"></div>
	<div id="properties" class="propiedades">
		<form id="formPropiedades">
			<div style="margin-bottom: 10px;">Seleccione Color: <input type="color" name="color" ></div>
			<div style="margin-bottom: 10px;">Habilitado: <input type="checkbox" name="enable" ></div>
			<div style="margin-bottom: 10px;">Rotar: 
				<select name="rotation" id="">
					<option value="0">0</option>
					<option value="90">90</option>
					<option value="180">180</option>
					<option value="270">270</option>
				</select>
			</div>
			<div style="text-align: center;"><input type="submit" value="Guardar"></div>
		</form>
	</div>
	<div id="previewSelect" class="preview"></div>
	<div id="buttons" class="control_buttons"></div>

	
	<style>
		#properties{
			position: absolute;
			overflow: hidden;
			left: 652px;
			top: 0px;
			width: 200px;
			height:300px;
			border: solid 1px #000000;
			padding: 5px;
			display: none;
		}
		.herramientas {
			position: absolute;
			overflow: hidden;
			left: 0px;
			top: 0px;
			width: 30px;
			padding: 5px;
			border: solid 1px #000000;
			border-radius: 5px;
			margin: 5px;

		}
		.flujo {
			position: absolute;
			overflow: hidden;
			left: 50px;
			width: 600px;
			height: 600px;
			border: 1px solid gray;
			background:url('images/wires-grid.gif');
			background-position:-1px 0px;
			cursor:crosshair;
		}
		.control_buttons {
			position: absolute;
			top: 610px;
			left: 50px;
			margin-top: 10px;
		}
		.preview{
			position: absolute;
			overflow: hidden;
			left:  650px;
			width: 60px;
			height: 60px;
		}
		.mxTooltip{
			position: absolute;
		}
		#toolbar .mxToolbarMode{
			margin-bottom: 5px 0px 0px 0px !important;
		}
		.propiedades{
			margin: 5px;
			padding: 5px;
			border-radius: 5px;
		}
	</style>

	<!-- Sets the basepath for the library if not in same directory -->
	<script type="text/javascript">
		mxBasePath = '../src';
	</script>

	<!-- Loads and initializes the library -->
	<script type="text/javascript" src="src/mxClient.js"></script>
	<script type="text/javascript">
		// If connect preview is not moved away then getCellAt is used to detect the cell under
		// the mouse if the mouse is over the preview shape in IE (no event transparency), ie.
		// the built-in hit-detection of the HTML document will not be used in this case.
		mxConnectionHandler.prototype.movePreviewAway = false;
		mxConnectionHandler.prototype.waypointsEnabled = true;
		mxGraph.prototype.resetEdgesOnConnect = false;
		mxConstants.SHADOWCOLOR = '#C0C0C0';
		var joinNodeSize = 7;
		var strokeWidth = 2;
		
		// Replaces the port image
	 	mxConstraintHandler.prototype.pointImage = new mxImage('images/dot.gif', 10, 10);
		
		// Enables guides
		mxGraphHandler.prototype.guidesEnabled = true;
		
	    // Alt disables guides
	    mxGuide.prototype.isEnabledForEvent = function(evt)
	    {
	    	return !mxEvent.isAltDown(evt);
	    };
		
		// Enables snapping waypoints to terminals
	 	mxEdgeHandler.prototype.snapToTerminals = true;


		 /* VARIABLES GENERALES*/
		var container = document.getElementById('graphContainer');
		var propertiesContainer = document.getElementById('properties');
		var previewContainer =  document.getElementById('previewSelect');
		var formProperties = document.getElementById('formPropiedades');
		var state = null;
		var selectedComponentProperties = {}


		var graph = new mxGraph(document.getElementById('graphContainer'));
		var parent = graph.getDefaultParent();

		// Adds a special tooltip for edges
		graph.setTooltips(true);

		var labelBackground =  '#FFFFFF';
		var fontColor =   '#000000';
		var strokeColor =  '#000000';
		var fillColor =   '#FFFFFF';
		
		var style = graph.getStylesheet().getDefaultEdgeStyle();
			delete style['endArrow'];
			style['strokeColor'] = strokeColor;
			style['labelBackgroundColor'] = labelBackground;
			style['edgeStyle'] = 'wireEdgeStyle';
			style['fontColor'] = fontColor;
			style['fontSize'] = '9';
			style['movable'] = '0';
			style['strokeWidth'] = strokeWidth;
			//style['rounded'] = '1';
			
			// Sets join node size
			style['startSize'] = joinNodeSize;
			style['endSize'] = joinNodeSize;
			
			style = graph.getStylesheet().getDefaultVertexStyle();
			style['gradientDirection'] = 'south';
			//style['gradientColor'] = '#909090';
			style['strokeColor'] = strokeColor;
			//style['fillColor'] = '#e0e0e0';
			style['fillColor'] = 'none';
			style['fontColor'] = fontColor;
			style['fontStyle'] = '1';
			style['fontSize'] = '12';
			style['resizable'] = '0';
			style['rounded'] = '1';
			style['strokeWidth'] = strokeWidth;
			style['portConstraintRotation'] = '1';
			style['rotation'] = '0';
			style['noLabel'] = '1';
			

			// Creates new toolbar without event processing
			var toolbar = new mxToolbar(document.getElementById('toolbar'));
			toolbar.enabled = false;

			var addVertex = function(icon, w, h, style, title)
				{
					var vertex = new mxCell(title, new mxGeometry(0, 0, w, h), style);
					
					vertex.setVertex(true);
				
					var img = addToolbarItem(graph, toolbar, vertex, icon, title);
					img.enabled = false;
					
					graph.getSelectionModel().addListener(mxEvent.CHANGE, function()
					{

						var tmp = graph.isSelectionEmpty();
						mxUtils.setOpacity(img, (tmp) ? 100 : 20);
						img.enabled = tmp;

					});


				};

			// TODO: RECORRER UN FOR PARA CADA ELEMENTO
				
		//	addVertex('images/toolbar/resistor.svg', 80, 40, 'shape=resistor;verticalLabelPosition=top', 'Resistor');
			addVertex('images/toolbar/EQC_INT.svg', 40, 40, 'shape=interruptor;image=images/toolbar/EQC_INT.svg;', 'Interuptor');
			addVertex('images/toolbar/EQC_SEC.svg', 40, 40, 'shape=seccionador;image=images/toolbar/EQC_SEC.svg;', 'Seccionador');
			addVertex('images/toolbar/EQS_TRAFO2.svg', 40, 40, 'shape=trafo_2;image=images/toolbar/EQS_TRAFO2.svg;', 'Trafo_2');
			addVertex('images/toolbar/EQS_TRAFO3.svg', 40, 40, 'shape=trafo_3;image=images/toolbar/EQS_TRAFO3.svg;', 'Trafo_3');

			// graph.getSelectionModel().addListener(mxEvent.CHANGE, function()
			// 		{
			// 			console.log('test');
			// 		})

			
	    function addToolbarItem(graph, toolbar, prototype, image, title)
		{
			// Function that is executed when the image is dropped on
			// the graph. The cell argument points to the cell under
			// the mousepointer if there is one.
			var funct = function(graph, evt, cell, x, y)
			{
				graph.stopEditing(false);

				var doc = mxUtils.createXmlDocument();

				var vertex = graph.getModel().cloneCell(prototype);
				vertex.geometry.x = x;
				vertex.geometry.y = y;
				var w = vertex.geometry.width;
				var h = vertex.geometry.height;

				graph.setCellStyles('noLabel', 1 );

				var node = doc.createElement(title)
				node.setAttribute('color', strokeColor);
				node.setAttribute('enable', false);
				node.setAttribute('rotation', '0');
				node.setAttribute('value', vertex.getValue());
				
			 	graph.insertVertex(graph.getDefaultParent(),null , node, x, y, w, h, vertex.style );
				
				
				console.log(vertex.getStyle())



				 // TODO: En la librería  * Class: mxCell línea 42503
				 // Se puede generar un metodo y una prop custom para guardar ahí las variables personalizadas, consularlo con los muchachos
				 // Por ahora se creó "custom"

				// graph.addCell(vertex);  //<-- CAMBIO LA FORMA DE GENERAR OBJETO

				// si deseo dejarlo seleccionado al soltarlo
				// graph.setSelectionCell(vertex);
			}
			
			// Creates the image which is used as the drag icon (preview)
			var img = toolbar.addMode(title, image, function(evt, cell)
			{
				var pt = this.graph.getPointForEvent(evt);
				funct(graph, evt, cell, pt.x, pt.y);
			});
			
			// Disables dragging if element is disabled. This is a workaround
			// for wrong event order in IE. Following is a dummy listener that
			// is invoked as the last listener in IE.
			mxEvent.addListener(img, 'mousedown', function(evt)
			{
				// do nothing
			});
			
			// This listener is always called first before any other listener
			// in all browsers.
			mxEvent.addListener(img, 'mousedown', function(evt)
			{
				if (img.enabled == false)
				{
					mxEvent.consume(evt);
				}
			});
						
			mxUtils.makeDraggable(img, graph, funct, previewContainer, 0 , 0 );
			
			return img;
		}

	//	Cambia el color al hacer click sobre un elemento

		graph.addMouseListener(
		{
			mouseDown: function(sender, me)
			{
			// cargo la variable global state con el objeto seleccionado	
			 state = me.state;
				if (state) {
					if(state.cell.vertex){
						propertiesContainer.style.display = 'block';
						// obtengo las propiedades generadas y las hago globales para cargarlas en el formulario
						formProperties.elements['color'].value = state.cell.value.getAttribute('color');
						formProperties.elements['rotation'].value = state.cell.value.getAttribute('rotation');
					 	formProperties.elements['enable'].checked = state.cell.value.getAttribute('enable') === 'true' ? true : false;
					
					} else {
						propertiesContainer.style.display = 'none';
					}
				}else {
					propertiesContainer.style.display = 'none';
				}
			},
			mouseMove: function(sender, me){},
			mouseUp: function(sender, me) {},
			dragEnter: function(evt, state){},
			dragLeave: function(evt, state){}
		});

		// mxEvent.addListener(img, 'click', function(evt){

		// })

		function updateStyle(state, properties)
		{
			console.log(state)
			// CAMBIO EN LA VISTA
			state.style[mxConstants.STYLE_STROKECOLOR] = properties.color;
			graph.setCellStyles('rotation', properties.rotation );
			graph.setCellStyles('strokeColor', properties.color );
			
			// actualiza los cambios en la vista.
			state.shape.apply(state);
			state.shape.redraw();

			// CAMBIO EN EL COMPONENTE (XML)
			state.cell.setAttribute('color', properties.color);
			state.cell.setAttribute('enable', properties.enable);
			state.cell.setAttribute('rotation', properties.rotation);
		 	// state.cell.style[mxConstants.STYLE_STROKECOLOR] = properties.color;

			
		};


		formProperties.addEventListener('change', function(e){
			e.preventDefault();

 			properties = {};
			properties.color = formProperties.elements['color'].value;
			properties.enable = formProperties.elements['enable'].checked;
			properties.rotation = formProperties.elements['rotation'].value;

			updateStyle(state, properties);
		});

		formProperties.addEventListener('submit', function(e){
			e.preventDefault();
			updateStyle(state, properties);
		});

		/* FUNCION PRINCIPAL */
		function main()
		{
		
			graph.view.scale = 1;
			graph.setPanning(true);
			graph.setConnectable(true);
			graph.setConnectableEdges(true);
			graph.setDisconnectOnMove(false);
			graph.foldingEnabled = false;
			
			//Maximum size
			graph.maximumGraphBounds = new mxRectangle(0, 0, 600, 600)
			graph.border = 50;

			// Panning handler consumed right click so this must be
			// disabled if right click should stop connection handler.
			graph.panningHandler.isPopupTrigger = function() { return false; };
			
			// Enables return key to stop editing (use shift-enter for newlines)
			graph.setEnterStopsCellEditing(true);

			// Adds rubberband selection
			new mxRubberband(graph);

		
			// Alternative solution for implementing connection points without child cells.
			// This can be extended as shown in portrefs.html example to allow for per-port
			// incoming/outgoing direction.
			graph.getAllConnectionConstraints = function(terminal)
			{
			   var geo = (terminal != null) ? this.getCellGeometry(terminal.cell) : null;
				// console.log('Geometría en la que está el mouse', geo);
				 console.log('Terminal en la que está el mouse', terminal);

				 //los puntos que forman la línea se obtienen de "absolutePoints" terminal.absolutePoints

			   if ((geo != null ? !geo.relative : false) &&
				   this.getModel().isVertex(terminal.cell) &&
				   this.getModel().getChildCount(terminal.cell) == 0)
			   {

				var ports = terminal.shape.getPorts();
				var cstrs = new Array();
				for (var id in ports)
						{
							var port = ports[id];
							
							var cstr = new mxConnectionConstraint(new mxPoint(port.x, port.y), port.perimeter);
							cstr.id = id;
							cstrs.push(cstr);
						}
						
						return cstrs;
				
			    }

				return null;
			};


			graph.setConnectionConstraint = function(edge, terminal, source, constraint)
			{
				if (constraint != null)
				{
					var key = (source) ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT;
					
					if (constraint == null || constraint.id == null)
					{
						this.setCellStyles(key, null, [edge]);
					}
					else if (constraint.id != null)
					{
						this.setCellStyles(key, constraint.id, [edge]);
					}
				}
			};

			// Returns the port for the given connection
			graph.getConnectionConstraint = function(edge, terminal, source)
			{
				var key = (source) ? mxConstants.STYLE_SOURCE_PORT : mxConstants.STYLE_TARGET_PORT;
				var id = edge.style[key];
				
				if (id != null)
				{
					var c =  new mxConnectionConstraint(null, null);
					c.id = id;
					
					return c;
				}
				
				return null;
			};

			// Returns the actual point for a port by redirecting the constraint to the port
			graphGetConnectionPoint = graph.getConnectionPoint;
			graph.getConnectionPoint = function(vertex, constraint)
			{
				if (constraint.id != null && vertex != null && vertex.shape != null)
				{
					var port = vertex.shape.getPorts()[constraint.id];
					
					if (port != null)
					{
						constraint = new mxConnectionConstraint(new mxPoint(port.x, port.y), port.perimeter);
					}
				}
				
				return graphGetConnectionPoint.apply(this, arguments);
			};
			// Makes sure non-relative cells can only be connected via constraints
			graph.connectionHandler.isConnectableCell = function(cell)
			{
				if (this.graph.getModel().isEdge(cell))
				{
					return true;
				}
				else
				{
					var geo = (cell != null) ? this.graph.getCellGeometry(cell) : null;
					
					return (geo != null) ? geo.relative : false;
				}
			};
			mxEdgeHandler.prototype.isConnectableCell = function(cell)
			{
				return graph.connectionHandler.isConnectableCell(cell);
			};
			
			// Adds a special tooltip for edges
			graph.setTooltips(true);
			
			var getTooltipForCell = graph.getTooltipForCell;
			graph.getTooltipForCell = function(cell)
			{
				var tip = '';
				
				if (cell != null)
				{
					var src = this.getModel().getTerminal(cell, true);
					
					if (src != null)
					{
						tip += this.getTooltipForCell(src) + ' ';
					}
					
					var parent = this.getModel().getParent(cell);
					
					if (this.getModel().isVertex(parent))
					{
						tip += this.getTooltipForCell(parent) + '.';
					}
	
					tip += getTooltipForCell.apply(this, arguments);
					
					var trg = this.getModel().getTerminal(cell, false);
					
					if (trg != null)
					{
						tip += ' ' + this.getTooltipForCell(trg);
					}
				}

				return tip;
			};


			graph.getModel().beginUpdate();
			try
			{
				// CABLES (No se si van)
				var b1 = graph.insertEdge(parent, null, 'B1' );
				b1.geometry.setTerminalPoint(new mxPoint(000, 20), true);
				b1.geometry.setTerminalPoint(new mxPoint(600, 20), false);
                
                var b2 = graph.insertEdge(parent, null, 'B2' );
				b2.geometry.setTerminalPoint(new mxPoint(000, 40), true);
				b2.geometry.setTerminalPoint(new mxPoint(600, 40), false);


                var _22kv = graph.insertEdge(parent, null, '22Kv' );
				_22kv.style = 'strokeColor=yellow';
				_22kv.geometry.setTerminalPoint(new mxPoint(000, 500), true);
				_22kv.geometry.setTerminalPoint(new mxPoint(600, 500), false);
                
                var _66kv = graph.insertEdge(parent, null, '66Kv' );
				_66kv.style = 'strokeColor=red';
				_66kv.geometry.setTerminalPoint(new mxPoint(000, 520), true);
				_66kv.geometry.setTerminalPoint(new mxPoint(600, 520), false);

                // var v2 = graph.insertVertex(parent, null, 'R1', 220, 220, 80, 20,
				// 	'shape=resistor;verticalLabelPosition=top;verticalAlign=bottom;strokeColor=#000000;');
                //     v2.setConnectable(true);

			}
			finally
			{
				graph.getModel().endUpdate();
			}

			var botonera = document.getElementById('buttons');
			
			botonera.appendChild(mxUtils.button('Zoom In', function()
			{
				graph.zoomIn();
			}));
			
			botonera.appendChild(mxUtils.button('Zoom Out', function()
			{
				graph.zoomOut();
			}));
			
			// Undo/redo
			var undoManager = new mxUndoManager();
			var listener = function(sender, evt)
			{
				undoManager.undoableEditHappened(evt.getProperty('edit'));
			};
			graph.getModel().addListener(mxEvent.UNDO, listener);
			graph.getView().addListener(mxEvent.UNDO, listener);
			
			botonera.appendChild(mxUtils.button('Undo', function()
			{
				undoManager.undo();
			}));
			
			botonera.appendChild(mxUtils.button('Redo', function()
			{
				undoManager.redo();
			}));

			// Delete
			botonera.appendChild(mxUtils.button('Delete', function()
			{
				graph.removeCells();
				propertiesContainer.style.display = 'none';
			}));

			// XML
			// Adds an option to view the XML of the graph
			botonera.appendChild(mxUtils.button('View XML', function()
			{
				var encoder = new mxCodec();
				var node = encoder.encode(graph.getModel());
				mxUtils.popup(mxUtils.getPrettyXml(node), true);
			}));

			botonera.appendChild(mxUtils.button('Save XML', function()
			{
				var encoder = new mxCodec();
				var node = encoder.encode(graph.getModel());

				 console.log(mxUtils.getPrettyXml(node));
				 localStorage.setItem('xml', mxUtils.getPrettyXml(node) );

				// json = xml2json(node, '');
				//console.log(JSON.parse(json));
				// mxUtils.popup(mxUtils.getPrettyXml(node), true);
			}));

			botonera.appendChild(mxUtils.button('Load XML', function()
			{
				var xml = localStorage.getItem('xml');
	//			console.log(mxUtils.parseXml(xml))
				var doc = mxUtils.parseXml(xml);
				var node = doc.documentElement;
				var dec = new mxCodec(node.ownerDocument);
				dec.decode(node, graph.getModel());

				console.log(doc)

			}));
			
			// Wire-mode
			var checkbox = document.createElement('input');
			checkbox.setAttribute('type', 'checkbox');
			
			botonera.appendChild(checkbox);
			mxUtils.write(botonera, 'Wire Mode');
			
			// Grid
			var checkbox2 = document.createElement('input');
			checkbox2.setAttribute('type', 'checkbox');
			checkbox2.setAttribute('checked', 'true');
			
			botonera.appendChild(checkbox2);
			mxUtils.write(botonera, 'Grid');
			
			mxEvent.addListener(checkbox2, 'click', function(evt)
			{
				if (checkbox2.checked)
				{
					container.style.background = 'url(\'images/wires-grid.gif\')';
				}
				else
				{ 
					container.style.background = '';
				}
				
				container.style.backgroundColor =  'white';
			});
			mxEvent.disableContextMenu(container);


			
			// Starts connections on the background in wire-mode
			var connectionHandlerIsStartEvent = graph.connectionHandler.isStartEvent;
			graph.connectionHandler.isStartEvent = function(me)
			{
				return checkbox.checked || connectionHandlerIsStartEvent.apply(this, arguments);
			};
			
			// Avoids any connections for gestures within tolerance except when in wire-mode
			// or when over a port
			var connectionHandlerMouseUp = graph.connectionHandler.mouseUp;
			graph.connectionHandler.mouseUp = function(sender, me)
			{
				if (this.first != null && this.previous != null)
				{
					var point = mxUtils.convertPoint(this.graph.container, me.getX(), me.getY());
					var dx = Math.abs(point.x - this.first.x);
					var dy = Math.abs(point.y - this.first.y);

					if (dx < this.graph.tolerance && dy < this.graph.tolerance)
					{
						// Selects edges in non-wire mode for single clicks, but starts
						// connecting for non-edges regardless of wire-mode
						if (!checkbox.checked && this.graph.getModel().isEdge(this.previous.cell))
						{
							this.reset();
						}
						
						return;
					}
				}
				
				connectionHandlerMouseUp.apply(this, arguments);
			};
			

		};

		// FUNCIONES PARA CONVERTIS XML A JSON Y VICEVERSA

		function json2xml(o, tab) {
		var toXml = function(v, name, ind) {
			var xml = "";
			if (v instanceof Array) {
				for (var i=0, n=v.length; i<n; i++)
					xml += ind + toXml(v[i], name, ind+"\t") + "\n";
			}
			else if (typeof(v) == "object") {
				var hasChild = false;
				xml += ind + "<" + name;
				for (var m in v) {
					if (m.charAt(0) == "@")
					xml += " " + m.substr(1) + "=\"" + v[m].toString() + "\"";
					else
					hasChild = true;
				}
				xml += hasChild ? ">" : "/>";
				if (hasChild) {
					for (var m in v) {
					if (m == "#text")
						xml += v[m];
					else if (m == "#cdata")
						xml += "<![CDATA[" + v[m] + "]]>";
					else if (m.charAt(0) != "@")
						xml += toXml(v[m], m, ind+"\t");
					}
					xml += (xml.charAt(xml.length-1)=="\n"?ind:"") + "</" + name + ">";
				}
			}
			else {
				xml += ind + "<" + name + ">" + v.toString() +  "</" + name + ">";
			}
			return xml;
		}, xml="";
		for (var m in o)
			xml += toXml(o[m], m, "");
		return tab ? xml.replace(/\t/g, tab) : xml.replace(/\t|\n/g, "");
		}


		function xml2json(xml, tab) {
		var X = {
			toObj: function(xml) {
				var o = {};
				if (xml.nodeType==1) {   // element node ..
					if (xml.attributes.length)   // element with attributes  ..
					for (var i=0; i<xml.attributes.length; i++)
						o["@"+xml.attributes[i].nodeName] = (xml.attributes[i].nodeValue||"").toString();
					if (xml.firstChild) { // element has child nodes ..
					var textChild=0, cdataChild=0, hasElementChild=false;
					for (var n=xml.firstChild; n; n=n.nextSibling) {
						if (n.nodeType==1) hasElementChild = true;
						else if (n.nodeType==3 && n.nodeValue.match(/[^ \f\n\r\t\v]/)) textChild++; // non-whitespace text
						else if (n.nodeType==4) cdataChild++; // cdata section node
					}
					if (hasElementChild) {
						if (textChild < 2 && cdataChild < 2) { // structured element with evtl. a single text or/and cdata node ..
							X.removeWhite(xml);
							for (var n=xml.firstChild; n; n=n.nextSibling) {
								if (n.nodeType == 3)  // text node
								o["#text"] = X.escape(n.nodeValue);
								else if (n.nodeType == 4)  // cdata node
								o["#cdata"] = X.escape(n.nodeValue);
								else if (o[n.nodeName]) {  // multiple occurence of element ..
								if (o[n.nodeName] instanceof Array)
									o[n.nodeName][o[n.nodeName].length] = X.toObj(n);
								else
									o[n.nodeName] = [o[n.nodeName], X.toObj(n)];
								}
								else  // first occurence of element..
								o[n.nodeName] = X.toObj(n);
							}
						}
						else { // mixed content
							if (!xml.attributes.length)
								o = X.escape(X.innerXml(xml));
							else
								o["#text"] = X.escape(X.innerXml(xml));
						}
					}
					else if (textChild) { // pure text
						if (!xml.attributes.length)
							o = X.escape(X.innerXml(xml));
						else
							o["#text"] = X.escape(X.innerXml(xml));
					}
					else if (cdataChild) { // cdata
						if (cdataChild > 1)
							o = X.escape(X.innerXml(xml));
						else
							for (var n=xml.firstChild; n; n=n.nextSibling)
								o["#cdata"] = X.escape(n.nodeValue);
					}
					}
					if (!xml.attributes.length && !xml.firstChild) o = null;
				}
				else if (xml.nodeType==9) { // document.node
					o = X.toObj(xml.documentElement);
				}
				else
					alert("unhandled node type: " + xml.nodeType);
				return o;
			},
			toJson: function(o, name, ind) {
				var json = name ? ("\""+name+"\"") : "";
				if (o instanceof Array) {
					for (var i=0,n=o.length; i<n; i++)
					o[i] = X.toJson(o[i], "", ind+"\t");
					json += (name?":[":"[") + (o.length > 1 ? ("\n"+ind+"\t"+o.join(",\n"+ind+"\t")+"\n"+ind) : o.join("")) + "]";
				}
				else if (o == null)
					json += (name&&":") + "null";
				else if (typeof(o) == "object") {
					var arr = [];
					for (var m in o)
					arr[arr.length] = X.toJson(o[m], m, ind+"\t");
					json += (name?":{":"{") + (arr.length > 1 ? ("\n"+ind+"\t"+arr.join(",\n"+ind+"\t")+"\n"+ind) : arr.join("")) + "}";
				}
				else if (typeof(o) == "string")
					json += (name&&":") + "\"" + o.toString() + "\"";
				else
					json += (name&&":") + o.toString();
				return json;
			},
			innerXml: function(node) {
				var s = ""
				if ("innerHTML" in node)
					s = node.innerHTML;
				else {
					var asXml = function(n) {
					var s = "";
					if (n.nodeType == 1) {
						s += "<" + n.nodeName;
						for (var i=0; i<n.attributes.length;i++)
							s += " " + n.attributes[i].nodeName + "=\"" + (n.attributes[i].nodeValue||"").toString() + "\"";
						if (n.firstChild) {
							s += ">";
							for (var c=n.firstChild; c; c=c.nextSibling)
								s += asXml(c);
							s += "</"+n.nodeName+">";
						}
						else
							s += "/>";
					}
					else if (n.nodeType == 3)
						s += n.nodeValue;
					else if (n.nodeType == 4)
						s += "<![CDATA[" + n.nodeValue + "]]>";
					return s;
					};
					for (var c=node.firstChild; c; c=c.nextSibling)
					s += asXml(c);
				}
				return s;
			},
			escape: function(txt) {
				return txt.replace(/[\\]/g, "\\\\")
						.replace(/[\"]/g, '\\"')
						.replace(/[\n]/g, '\\n')
						.replace(/[\r]/g, '\\r');
			},
			removeWhite: function(e) {
				e.normalize();
				for (var n = e.firstChild; n; ) {
					if (n.nodeType == 3) {  // text node
					if (!n.nodeValue.match(/[^ \f\n\r\t\v]/)) { // pure whitespace text node
						var nxt = n.nextSibling;
						e.removeChild(n);
						n = nxt;
					}
					else
						n = n.nextSibling;
					}
					else if (n.nodeType == 1) {  // element node
					X.removeWhite(n);
					n = n.nextSibling;
					}
					else                      // any other node
					n = n.nextSibling;
				}
				return e;
			}
		};
		if (xml.nodeType == 9) // document node
			xml = xml.documentElement;
		var json = X.toJson(X.toObj(X.removeWhite(xml)), xml.nodeName, "\t");
		return "{\n" + tab + (tab ? json.replace(/\t/g, tab) : json.replace(/\t|\n/g, "")) + "\n}";
		}




	</script>
<!--  
		Updates connection points before the routing is called.
-->
	<script type="text/javascript">
		// Computes the position of edge to edge connection points.
		mxGraphView.prototype.updateFixedTerminalPoint = function(edge, terminal, source, constraint)
		{
			var pt = null;
			
			if (constraint != null)
			{
				pt = this.graph.getConnectionPoint(terminal, constraint);
			}

			if (source)
			{
				edge.sourceSegment = null;
			}
			else
			{
				edge.targetSegment = null;
			}
			
			if (pt == null)
			{
				var s = this.scale;
				var tr = this.translate;
				var orig = edge.origin;
				var geo = this.graph.getCellGeometry(edge.cell);
				pt = geo.getTerminalPoint(source);

				// Computes edge-to-edge connection point
				if (pt != null)
				{
					pt = new mxPoint(s * (tr.x + pt.x + orig.x),
									 s * (tr.y + pt.y + orig.y));
					
					// Finds nearest segment on edge and computes intersection
					if (terminal != null && terminal.absolutePoints != null)
					{
						var seg = mxUtils.findNearestSegment(terminal, pt.x, pt.y);

						// Finds orientation of the segment
						var p0 = terminal.absolutePoints[seg];
						var pe = terminal.absolutePoints[seg + 1];
						var horizontal = (p0.x - pe.x == 0);
						
						// Stores the segment in the edge state
						var key = (source) ? 'sourceConstraint' : 'targetConstraint';
						var value = (horizontal) ? 'horizontal' : 'vertical';
						edge.style[key] = value;
						
						// Keeps the coordinate within the segment bounds
						if (horizontal)
						{
							pt.x = p0.x;
							pt.y = Math.min(pt.y, Math.max(p0.y, pe.y));
							pt.y = Math.max(pt.y, Math.min(p0.y, pe.y));
						}
						else
						{
							pt.y = p0.y;
							pt.x = Math.min(pt.x, Math.max(p0.x, pe.x));
							pt.x = Math.max(pt.x, Math.min(p0.x, pe.x));
						}
					}
				}
				// Computes constraint connection points on vertices and ports
				else if (terminal != null && terminal.cell.geometry.relative)
				{
					pt = new mxPoint(this.getRoutingCenterX(terminal),
						this.getRoutingCenterY(terminal));
				}

				// Snaps point to grid
				/*if (pt != null)
				{
					var tr = this.graph.view.translate;
					var s = this.graph.view.scale;
					
					pt.x = (this.graph.snap(pt.x / s - tr.x) + tr.x) * s;
					pt.y = (this.graph.snap(pt.y / s - tr.y) + tr.y) * s;
				}*/
			}

			edge.setAbsoluteTerminalPoint(pt, source);
		};
	</script>
<!--  
	Overrides methods to preview and create new edges.
-->
	<script type="text/javascript">
		// Sets source terminal point for edge-to-edge connections.
		mxConnectionHandler.prototype.createEdgeState = function(me)
		{
			var edge = this.graph.createEdge();
			
			if (this.sourceConstraint != null && this.previous != null)
			{
				edge.style = mxConstants.STYLE_EXIT_X+'='+this.sourceConstraint.point.x+';'+
					mxConstants.STYLE_EXIT_Y+'='+this.sourceConstraint.point.y+';';
			}
			else if (this.graph.model.isEdge(me.getCell()))
			{
				var scale = this.graph.view.scale;
				var tr = this.graph.view.translate;
				var pt = new mxPoint(this.graph.snap(me.getGraphX() / scale) - tr.x,
						this.graph.snap(me.getGraphY() / scale) - tr.y);
				edge.geometry.setTerminalPoint(pt, true);
			}
			
			return this.graph.view.createState(edge);
		};
		
		// Uses right mouse button to create edges on background (see also: lines 67 ff)
		mxConnectionHandler.prototype.isStopEvent = function(me)
		{
			return me.getState() != null || mxEvent.isRightMouseButton(me.getEvent());
		};
		
		// Updates target terminal point for edge-to-edge connections.
		mxConnectionHandlerUpdateCurrentState = mxConnectionHandler.prototype.updateCurrentState;
		mxConnectionHandler.prototype.updateCurrentState = function(me)
		{
			mxConnectionHandlerUpdateCurrentState.apply(this, arguments);

			if (this.edgeState != null)
			{
				this.edgeState.cell.geometry.setTerminalPoint(null, false);
			
				if (this.shape != null && this.currentState != null &&
					this.currentState.view.graph.model.isEdge(this.currentState.cell))
				{
					var scale = this.graph.view.scale;
					var tr = this.graph.view.translate;
					var pt = new mxPoint(this.graph.snap(me.getGraphX() / scale) - tr.x,
							this.graph.snap(me.getGraphY() / scale) - tr.y);
					this.edgeState.cell.geometry.setTerminalPoint(pt, false);
				}
			}
		};

		// Updates the terminal and control points in the cloned preview.
		mxEdgeSegmentHandler.prototype.clonePreviewState = function(point, terminal)
		{
			var clone = mxEdgeHandler.prototype.clonePreviewState.apply(this, arguments);
			clone.cell = clone.cell.clone();
			
			if (this.isSource || this.isTarget)
			{
				clone.cell.geometry = clone.cell.geometry.clone();
				
				// Sets the terminal point of an edge if we're moving one of the endpoints
				if (this.graph.getModel().isEdge(clone.cell))
				{
					// TODO: Only set this if the target or source terminal is an edge
					clone.cell.geometry.setTerminalPoint(point, this.isSource);
				}
				else
				{
					clone.cell.geometry.setTerminalPoint(null, this.isSource);				
				}
			}

			return clone;
		};
		
		var mxEdgeHandlerConnect = mxEdgeHandler.prototype.connect;
		mxEdgeHandler.prototype.connect = function(edge, terminal, isSource, isClone, me)
		{
			var result = null;
			var model = this.graph.getModel();
			var parent = model.getParent(edge);
			
			model.beginUpdate();
			try
			{
				result = mxEdgeHandlerConnect.apply(this, arguments);
				var geo = model.getGeometry(result);
				
				if (geo != null)
				{
					geo = geo.clone();
					var pt = null;
					
					if (model.isEdge(terminal))
					{
						pt = this.abspoints[(this.isSource) ? 0 : this.abspoints.length - 1];
						pt.x = pt.x / this.graph.view.scale - this.graph.view.translate.x;
						pt.y = pt.y / this.graph.view.scale - this.graph.view.translate.y;
			
						var pstate = this.graph.getView().getState(
								this.graph.getModel().getParent(edge));
								
						if (pstate != null)
						{
							pt.x -= pstate.origin.x;
							pt.y -= pstate.origin.y;
						}
						
						pt.x -= this.graph.panDx / this.graph.view.scale;
						pt.y -= this.graph.panDy / this.graph.view.scale;
					}
				
					geo.setTerminalPoint(pt, isSource);
					model.setGeometry(edge, geo);
				}
			}
			finally
			{
				model.endUpdate();
			}
			
			return result;
		};
	</script>
<!--  
	Adds in-place highlighting for complete cell area (no hotspot).
-->
	<script type="text/javascript">
		mxConnectionHandlerCreateMarker = mxConnectionHandler.prototype.createMarker;
		mxConnectionHandler.prototype.createMarker = function()
		{
			var marker = mxConnectionHandlerCreateMarker.apply(this, arguments);
			
			// Uses complete area of cell for new connections (no hotspot)
			marker.intersects = function(state, evt)
			{
				return true;
			};
			
			// Adds in-place highlighting
			mxCellHighlightHighlight = mxCellHighlight.prototype.highlight;
			marker.highlight.highlight = function(state)
			{
				if (this.state != state)
				{
					if (this.state != null)
					{
						this.state.style = this.lastStyle;
						
						// Workaround for shape using current stroke width if no strokewidth defined
						this.state.style['strokeWidth'] = this.state.style['strokeWidth'] || '1';
						this.state.style['strokeColor'] = this.state.style['strokeColor'] || 'none';
						
						if (this.state.shape != null)
						{
							this.state.view.graph.cellRenderer.configureShape(this.state);
							this.state.shape.redraw();
						}
					}
					
					if (state != null)
					{
						this.lastStyle = state.style;
						state.style = mxUtils.clone(state.style);
						state.style['strokeColor'] = '#00ff00';
						state.style['strokeWidth'] = '3';
						
						if (state.shape != null)
						{
							state.view.graph.cellRenderer.configureShape(state);
							state.shape.redraw();
						}
					}
					
					this.state = state;
				}
			};
			
			return marker;
		};
		
		mxEdgeHandlerCreateMarker = mxEdgeHandler.prototype.createMarker;
		mxEdgeHandler.prototype.createMarker = function()
		{
			var marker = mxEdgeHandlerCreateMarker.apply(this, arguments);
			
			// Adds in-place highlighting when reconnecting existing edges
			marker.highlight.highlight = this.graph.connectionHandler.marker.highlight.highlight;
			
			return marker;
		}
	</script>
<!--  
	Adds oval markers for edge-to-edge connections.
-->
	<script type="text/javascript">
		mxGraphGetCellStyle = mxGraph.prototype.getCellStyle;
		mxGraph.prototype.getCellStyle = function(cell)
		{
			var style = mxGraphGetCellStyle.apply(this, arguments);
			
			if (style != null && this.model.isEdge(cell))
			{
				style = mxUtils.clone(style);
				
				if (this.model.isEdge(this.model.getTerminal(cell, true)))
				{
					style['startArrow'] = 'oval';
				}
		
				if (this.model.isEdge(this.model.getTerminal(cell, false)))
				{
					style['endArrow'] = 'oval';
				}
			}
			
			return style;
		};
	</script>
<!--  
	Implemento las formas Customs con sus respectivos puntos de conexiones
-->
	<script type="text/javascript">
		// CONVENSION DE NOMBRE DE PUERTOS CONETABLES; 
		// SENTIDO HORARIO COMENZANDO DESDE LAS 12:HS
/*
		function ResistorShape() { };
		ResistorShape.prototype = new mxCylinder();
		ResistorShape.prototype.constructor = ResistorShape;

		ResistorShape.prototype.redrawPath = function(path, x, y, w, h, isForeground)
		{
			var dx = w / 16;

			if (isForeground)
			{
				path.moveTo(0, h / 2);
				path.lineTo(2 * dx, h / 2);
				path.lineTo(3 * dx, 0);
				path.lineTo(5 * dx, h);
				path.lineTo(7 * dx, 0);
				path.lineTo(9 * dx, h);
				path.lineTo(11 * dx, 0);
				path.lineTo(13 * dx, h);
				path.lineTo(14 * dx, h / 2);
				path.lineTo(16 * dx, h / 2);

				path.end();
			}
		};

		mxCellRenderer.registerShape('resistor', ResistorShape);
		ResistorShape.prototype.getPorts = function()
			{
				var ports = new Array();
				ports['a'] = {x: 0, y: 0.5, perimeter: true, constraint: 'west'};
				ports['b'] = {x: 1, y: 0.5, perimeter: true, constraint: 'east'};
				ports['c'] = {x: 0.5, y: 0, perimeter: true, constraint: 'north'};
				ports['d'] = {x: 0.5, y: 1, perimeter: true, constraint: 'south'};

				return ports;
			};
*/
		function SeccionadorShape(){};
		SeccionadorShape.prototype = new mxImageShape();
		SeccionadorShape.prototype.constructor = SeccionadorShape;

		mxCellRenderer.registerShape('seccionador', SeccionadorShape);
		SeccionadorShape.prototype.getPorts = function()
			{
				var ports = new Array();
				ports['Se_1'] = {x: 0, y: 0.5, };
				ports['Se_2'] = {x: 1, y: 0.5, };
				ports['Se_3'] = {x: 0.5, y: 0, };
				ports['Se_4'] = {x: 0.5, y: 1, };

				return ports;
			};


		function InterruptorShape(){};
		InterruptorShape.prototype = new mxImageShape();
		InterruptorShape.prototype.constructor = InterruptorShape;

		mxCellRenderer.registerShape('interruptor', InterruptorShape);

		InterruptorShape.prototype.getPorts = function()
			{
				var ports = new Array();
				ports['In_1'] = {x: 1, y: 0.5, perimeter: true, constraint: 'east'};
				ports['In_2'] = {x: 0.5, y: 0, perimeter: true, constraint: 'north'};
				ports['In_3'] = {x: 0.5, y: 1, perimeter: true, constraint: 'south'};
				ports['In_4'] = {x: 0, y: 0.5, perimeter: true, constraint: 'west'};

				return ports;
			};

		function Trafo2Shape(){};
		Trafo2Shape.prototype = new mxImageShape();
		Trafo2Shape.prototype.constructor = Trafo2Shape;

		mxCellRenderer.registerShape('trafo_2', Trafo2Shape);

		Trafo2Shape.prototype.getPorts = function()
			{
				var ports = new Array();
				ports['t2_1'] = {x: 0.5, y: 1, perimeter: true, constraint: 'west'};
				ports['t2_2'] = {x: 0.5, y: 0, perimeter: true, constraint: 'east'};

				return ports;
			};

			function Trafo3Shape(){};
		Trafo3Shape.prototype = new mxImageShape();
		Trafo3Shape.prototype.constructor = Trafo3Shape;

		mxCellRenderer.registerShape('trafo_3', Trafo3Shape);

		Trafo3Shape.prototype.getPorts = function()
			{
				var ports = new Array();
				ports['t3_1'] = {x: 0.5, y: 0, perimeter: true, constraint: 'west'};
				ports['t3_2'] = {x: 0.1, y: 1, perimeter: true, constraint: 'east'};
				ports['t3_3'] = {x: 0.9, y: 1, perimeter: true, constraint: 'north'};
				
				return ports;
			};
		console.log(Trafo3Shape.prototype);
			


	</script>


	<script type="text/javascript">
	mxEdgeStyle.WireConnector = function(state, source, target, hints, result)
	{
		// Creates array of all way- and terminalpoints
		var pts = state.absolutePoints;
		var horizontal = true;
		var hint = null;
		
		// Gets the initial connection from the source terminal or edge
		if (source != null && state.view.graph.model.isEdge(source.cell))
		{
			horizontal = state.style['sourceConstraint'] == 'horizontal';
		}
		else if (source != null)
		{
			horizontal = source.style['portConstraint'] != 'vertical';
			
			// Checks the direction of the shape and rotates
			var direction = source.style[mxConstants.STYLE_DIRECTION];
			
			if (direction == 'north' || direction == 'south')
			{
				horizontal = !horizontal;
			}
		}
		
		// Adds the first point
		// TODO: Should move along connected segment
		var pt = pts[0];
		
		if (pt == null && source != null)
		{
			pt = new mxPoint(state.view.getRoutingCenterX(source), state.view.getRoutingCenterY(source));
		}
		else if (pt != null)
		{
			pt = pt.clone();
		}
		
		var first = pt;

		// Adds the waypoints
		if (hints != null && hints.length > 0)
		{
			// FIXME: First segment not movable
			/*hint = state.view.transformControlPoint(state, hints[0]);
			mxLog.show();
			mxLog.debug(hints.length,'hints0.y='+hint.y, pt.y)
			
			if (horizontal && Math.floor(hint.y) != Math.floor(pt.y))
			{
				mxLog.show();
				mxLog.debug('add waypoint');

				pt = new mxPoint(pt.x, hint.y);
				result.push(pt);
				pt = pt.clone();
				//horizontal = !horizontal;
			}*/
			
			for (var i = 0; i < hints.length; i++)
			{
				horizontal = !horizontal;
				hint = state.view.transformControlPoint(state, hints[i]);

				if (horizontal)
				{
					if (pt.y != hint.y)
					{
						pt.y = hint.y;
						result.push(pt.clone());
					}
				}
				else if (pt.x != hint.x)
				{
					pt.x = hint.x;
					result.push(pt.clone());
				}
			}
		}
		else
		{
			hint = pt;
		}

		// Adds the last point
		pt = pts[pts.length - 1];

		// TODO: Should move along connected segment
		if (pt == null && target != null)
		{
			pt = new mxPoint(state.view.getRoutingCenterX(target), state.view.getRoutingCenterY(target));
		}

		if (horizontal)
		{
			if (pt.y != hint.y && first.x != pt.x)
			{
				result.push(new mxPoint(pt.x, hint.y));
			}
		}
		else if (pt.x != hint.x && first.y != pt.y)
		{
			result.push(new mxPoint(hint.x, pt.y));
		}
	};
	
	mxStyleRegistry.putValue('wireEdgeStyle', mxEdgeStyle.WireConnector);
	
	// This connector needs an mxEdgeSegmentHandler
	mxGraphCreateHandler = mxGraph.prototype.createHandler;
	mxGraph.prototype.createHandler = function(state)
	{
		var result = null;
		
		if (state != null)
		{
			if (this.model.isEdge(state.cell))
			{
				var style = this.view.getEdgeStyle(state);
				
				if (style == mxEdgeStyle.WireConnector)
				{
					return new mxEdgeSegmentHandler(state);
				}
			}
		}
		
		return mxGraphCreateHandler.apply(this, arguments);
	};
	</script>


</body>
</html>
